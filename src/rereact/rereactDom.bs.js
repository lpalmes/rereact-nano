// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list.js");
var Block      = require("bs-platform/lib/js/block.js");
var Curry      = require("bs-platform/lib/js/curry.js");
var Rereact    = require("./rereact.bs.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

var globalInstance = [/* IFlat */Block.__(0, [/* [] */0])];

function addProps(domElement, props) {
  var match = props[/* id */0];
  if (match) {
    domElement.setAttribute("id", match[0]);
  }
  var match$1 = props[/* className */2];
  if (match$1) {
    domElement.setAttribute("class", match$1[0]);
  }
  var match$2 = props[/* value */1];
  if (match$2) {
    domElement.setAttribute("value", match$2[0]);
  }
  var match$3 = props[/* onClick */3];
  if (match$3) {
    var func = match$3[0];
    domElement.addEventListener("click", (function () {
            return Curry._1(func, /* () */0);
          }));
  }
  var match$4 = props[/* onChange */4];
  if (match$4) {
    var func$1 = match$4[0];
    domElement.addEventListener("change", (function () {
            return Curry._1(func$1, /* () */0);
          }));
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function executePendingStateUpdates(opaqueInstance) {
  var instance = opaqueInstance[0];
  var executeUpdate = function (state, stateUpdate) {
    var match = Curry._1(stateUpdate, state);
    if (match) {
      return match[0];
    } else {
      return state;
    }
  };
  var executeUpdates = function (_state, _stateUpdates) {
    while(true) {
      var stateUpdates = _stateUpdates;
      var state = _state;
      if (stateUpdates) {
        var nextState = executeUpdate(state, stateUpdates[0]);
        _stateUpdates = stateUpdates[1];
        _state = nextState;
        continue ;
        
      } else {
        return state;
      }
    };
  };
  var pendingUpdates = List.rev(instance[/* pendingStateUpdates */5][0]);
  instance[/* pendingStateUpdates */5][0] = /* [] */0;
  var nextState = executeUpdates(instance[/* iState */2], pendingUpdates);
  instance[/* iState */2] = nextState;
  return /* () */0;
}

function createInstance(component, element) {
  var iState = Curry._1(component[/* initialState */2], /* () */0);
  return /* record */[
          /* component */component,
          /* element */element,
          /* iState */iState,
          /* instanceSubTree : IFlat */Block.__(0, [/* [] */0]),
          /* dom */document.createElement("span"),
          /* pendingStateUpdates */[/* [] */0]
        ];
}

function mapListToOptionals(b) {
  return List.map((function (a) {
                return /* Some */[a];
              }), b);
}

function addOptionalElements(howMany) {
  if (howMany) {
    return Pervasives.$at(/* :: */[
                /* None */0,
                /* [] */0
              ], addOptionalElements(howMany - 1 | 0));
  } else {
    return /* [] */0;
  }
}

function equalizeList(a, b) {
  var aLength = List.length(a);
  var bLength = List.length(b);
  if (aLength === bLength) {
    return /* tuple */[
            List.map((function (a) {
                    return /* Some */[a];
                  }), a),
            List.map((function (a) {
                    return /* Some */[a];
                  }), b)
          ];
  } else {
    var maxLength = Pervasives.max(aLength, bLength);
    if (aLength === maxLength) {
      return /* tuple */[
              List.map((function (a) {
                      return /* Some */[a];
                    }), a),
              Pervasives.$at(List.map((function (a) {
                          return /* Some */[a];
                        }), b), addOptionalElements(aLength - bLength | 0))
            ];
    } else {
      return /* tuple */[
              Pervasives.$at(List.map((function (a) {
                          return /* Some */[a];
                        }), a), addOptionalElements(bLength - aLength | 0)),
              List.map((function (a) {
                      return /* Some */[a];
                    }), b)
            ];
    }
  }
}

function reconcile(parentDom, instance, element) {
  if (instance) {
    var match = instance[0];
    if (match.tag) {
      var dom = match[2];
      var iName = match[0];
      if (element) {
        var match$1 = element[0];
        if (match$1.tag) {
          var elements = match$1[2];
          var name = match$1[0];
          if (iName !== name) {
            parentDom.removeChild(dom);
            var node = document.createElement(name);
            parentDom.appendChild(node);
            addProps(node, match$1[1]);
            var els = List.rev(List.fold_left((function (instances, e) {
                        if (e) {
                          return /* :: */[
                                  e[0],
                                  instances
                                ];
                        } else {
                          return instances;
                        }
                      }), /* [] */0, List.map((function (param) {
                            return reconcile(node, /* None */0, param);
                          }), List.map((function (e) {
                                return /* Some */[e];
                              }), elements))));
            return /* Some */[/* INested */Block.__(1, [
                        name,
                        els,
                        node
                      ])];
          } else if (iName === name) {
            var match$2 = equalizeList(match[1], elements);
            var b = match$2[1];
            var a = match$2[0];
            if (List.length(a) !== List.length(b)) {
              console.log("Lists are different size");
              console.log(List.length(a));
              console.log(List.length(b));
            }
            var els$1 = List.rev(List.fold_left((function (instances, e) {
                        if (e) {
                          return /* :: */[
                                  e[0],
                                  instances
                                ];
                        } else {
                          return instances;
                        }
                      }), /* [] */0, List.map2((function (param, param$1) {
                            return reconcile(dom, param, param$1);
                          }), a, b)));
            return /* Some */[/* INested */Block.__(1, [
                        name,
                        els$1,
                        dom
                      ])];
          } else {
            return /* None */0;
          }
        } else {
          return /* None */0;
        }
      } else {
        parentDom.removeChild(dom);
        return /* None */0;
      }
    } else if (element) {
      var match$3 = element[0];
      if (match$3.tag) {
        return /* None */0;
      } else {
        var els$2 = List.rev(List.fold_left((function (instances, e) {
                    if (e) {
                      return /* :: */[
                              e[0],
                              instances
                            ];
                    } else {
                      return instances;
                    }
                  }), /* [] */0, List.map2((function (param, param$1) {
                        return reconcileElement(parentDom, param, param$1);
                      }), List.map((function (i) {
                            return /* Some */[i];
                          }), match[0]), match$3[0])));
        return /* Some */[/* IFlat */Block.__(0, [els$2])];
      }
    } else {
      return /* None */0;
    }
  } else if (element) {
    var match$4 = element[0];
    if (match$4.tag) {
      var name$1 = match$4[0];
      var node$1 = document.createElement(name$1);
      parentDom.appendChild(node$1);
      addProps(node$1, match$4[1]);
      var els$3 = List.rev(List.fold_left((function (instances, e) {
                  if (e) {
                    return /* :: */[
                            e[0],
                            instances
                          ];
                  } else {
                    return instances;
                  }
                }), /* [] */0, List.map((function (param) {
                      return reconcile(node$1, /* None */0, param);
                    }), List.map((function (e) {
                          return /* Some */[e];
                        }), match$4[2]))));
      return /* Some */[/* INested */Block.__(1, [
                  name$1,
                  els$3,
                  node$1
                ])];
    } else {
      var els$4 = List.fold_left((function (instances, e) {
              if (e) {
                return /* :: */[
                        e[0],
                        instances
                      ];
              } else {
                return instances;
              }
            }), /* [] */0, List.map((function (param) {
                  return reconcileElement(parentDom, /* None */0, param);
                }), match$4[0]));
      return /* Some */[/* IFlat */Block.__(0, [els$4])];
    }
  } else {
    return /* None */0;
  }
}

function reconcileElement(parentDom, instance, element) {
  if (instance) {
    var instance$1 = instance[0][0];
    var match = instance$1[/* element */1];
    if (match.tag) {
      var instanceSubTree = instance$1[/* instanceSubTree */3];
      var dom = instance$1[/* dom */4];
      if (element.tag) {
        var newComponent = element[0];
        instance$1[/* component */0] = newComponent;
        var self = createSelf(instance$1);
        var subElements = Curry._1(newComponent[/* render */1], self);
        var instanceSubTree$1 = reconcile(dom, /* Some */[instanceSubTree], /* Some */[subElements]);
        if (instanceSubTree$1) {
          var v = instanceSubTree$1[0];
          if (v.tag) {
            instance$1[/* dom */4] = v[2];
          }
          instance$1[/* instanceSubTree */3] = v;
        }
        var newrecord = instance$1.slice();
        return /* Some */[/* Instance */[(newrecord[/* element */1] = element, newrecord)]];
      } else {
        return /* None */0;
      }
    } else {
      var dom$1 = instance$1[/* dom */4];
      if (element.tag) {
        return /* None */0;
      } else {
        var value = element[0];
        if (match[0] === value) {
          return /* Some */[/* Instance */[instance$1]];
        } else {
          dom$1.innerText = value;
          var newrecord$1 = instance$1.slice();
          return /* Some */[/* Instance */[(newrecord$1[/* element */1] = element, newrecord$1)]];
        }
      }
    }
  } else if (element.tag) {
    var component = element[0];
    var instance$2 = createInstance(component, element);
    var self$1 = createSelf(instance$2);
    var subElements$1 = Curry._1(component[/* render */1], self$1);
    var instanceSubTree$2 = reconcile(parentDom, /* None */0, /* Some */[subElements$1]);
    if (instanceSubTree$2) {
      var v$1 = instanceSubTree$2[0];
      if (v$1.tag) {
        instance$2[/* dom */4] = v$1[2];
      }
      instance$2[/* instanceSubTree */3] = v$1;
    }
    Curry._1(component[/* didMount */3], self$1);
    return /* Some */[/* Instance */[instance$2]];
  } else {
    parentDom.innerText = element[0];
    return /* Some */[/* Instance */[/* record */[
                /* component */Rereact.basicComponent("String"),
                /* element */element,
                /* iState : () */0,
                /* instanceSubTree : IFlat */Block.__(0, [/* [] */0]),
                /* dom */parentDom,
                /* pendingStateUpdates */[/* [] */0]
              ]]];
  }
}

function createSelf(instance) {
  return /* record */[
          /* state */instance[/* iState */2],
          /* reduce */(function (payloadToAction, payload) {
              var action = Curry._1(payloadToAction, payload);
              var stateUpdate = Curry._1(instance[/* component */0][/* reducer */4], action);
              instance[/* pendingStateUpdates */5][0] = /* :: */[
                stateUpdate,
                instance[/* pendingStateUpdates */5][0]
              ];
              executePendingStateUpdates(/* Instance */[instance]);
              reconcileElement(instance[/* dom */4], /* Some */[/* Instance */[instance]], instance[/* element */1]);
              return /* () */0;
            }),
          /* send */(function (action) {
              var stateUpdate = Curry._1(instance[/* component */0][/* reducer */4], action);
              instance[/* pendingStateUpdates */5][0] = /* :: */[
                stateUpdate,
                instance[/* pendingStateUpdates */5][0]
              ];
              executePendingStateUpdates(/* Instance */[instance]);
              console.log(instance[/* component */0][/* debugName */0]);
              reconcileElement(instance[/* dom */4], /* Some */[/* Instance */[instance]], instance[/* element */1]);
              return /* () */0;
            })
        ];
}

var parentContainer = [document.createElement("span")];

var rootInstance = [/* None */0];

function render(reactElement, parentDom) {
  parentContainer[0] = parentDom;
  rootInstance[0] = reconcile(parentDom, rootInstance[0], /* Some */[reactElement]);
  var match = rootInstance[0];
  if (match) {
    return match[0];
  } else {
    return /* IFlat */Block.__(0, [/* [] */0]);
  }
}

function hotUpdate(reactElement, instance) {
  var match = reconcile(parentContainer[0], /* Some */[instance], /* Some */[reactElement]);
  if (match) {
    return match[0];
  } else {
    return /* IFlat */Block.__(0, [/* [] */0]);
  }
}

exports.globalInstance             = globalInstance;
exports.addProps                   = addProps;
exports.executePendingStateUpdates = executePendingStateUpdates;
exports.createInstance             = createInstance;
exports.mapListToOptionals         = mapListToOptionals;
exports.addOptionalElements        = addOptionalElements;
exports.equalizeList               = equalizeList;
exports.reconcile                  = reconcile;
exports.reconcileElement           = reconcileElement;
exports.createSelf                 = createSelf;
exports.parentContainer            = parentContainer;
exports.rootInstance               = rootInstance;
exports.render                     = render;
exports.hotUpdate                  = hotUpdate;
/* parentContainer Not a pure module */
